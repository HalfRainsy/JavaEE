1：如何看待死锁
    不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。




面试题：synchronize同步的方式与lock的对比？

synchronize不管是同步代码块还是同步方法，都需要在结束一对{}之后，释放对同步监视器的调用。
lock是通过两个方法控制需要被同步的代码，更灵活一些。
lock作为接口，提供了多种实现类，适合更复杂的场景，效率更高。



wait()  和 sleep()的区别
一旦执行当前线程都会进行阻塞的状态。
不同点：
>声明的位置：wait()声明再object类中    sleep()声明在Thread类中，静态的
>使用场景不同：wait()只能使用在同步代码块或同步方法中   sleep()可以在任何需要使用的场景
>使用在同步代码块或同步方法中：wait()：一旦执行，会释放同步监视器   sleep()一旦执行，不会释放同步监视器
>结束阻塞的方式：wait():到达指定时间自动结束阻塞，或通过呗notify()唤醒，结束阻塞   sleep():到达指定时间自动结束阻塞
