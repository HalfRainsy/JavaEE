1：super关键字的使用
    1：为什么要使用super？
        ①：子类继承父类以后，对父类的方法进行的重写，那么在子类中，是否还可以对父类中被重写的方法进行调用？
            可以；
        ②：子类继承父类以后，发现子类和父类中定义了同名的属性，是否可以在子类中区分两个同名的属性？
        可以。
        如何调用？如何使用？
            使用super关键子。
    2：对super的理解
        super   父类的
    3：super可以调用的界沟：属性，方法，构造器

具体：3-1：super调用属性、方法
    子类继承父类以后，我们就可以在子类的方法、或者构造器调用父类中声明的属性或方法。(满足封装性的方法)
    调用时  使用   ‘super.’  的界沟， 表示调用父类的属性或方法。
    一般情况下，可以省略‘super.’的结构，但是，如果出现了子类重写了父类的方法或子父类出现了相同名字的属性时，
    则必须使用‘super.’的声明。但是在开发时，最好子父类之间不要存在于相同的命名。
    3-2：super调用构造器
    如果没有super调用构造器，则没有实例化的过程。
    ① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。

    ② 规定：“super(形参列表)”，必须声明在构造器的首行。

    ③ 我们前面讲过，在构造器的首行可以使用"this(形参列表)"，调用本类中重载的构造器，
         结合②，结论：在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。

    ④ 如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，
       则子类此构造器默认调用"super()"，即调用父类中空参的构造器。

    ⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。
         只能是这两种情况之一。

    ⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了"this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。

    -->我们在通过子类的构造器创建对象时，一定实在调用子类构造器的过程中，直接或间接的调用到父类的构造器。
    也正因为调用过父类的构造器，我们才会将父类中声明的属性、方法加载到内存中，供子类的使用。

    子类对象实例化的全过程
    1：代码举例：
        class Creature{//生物类
        //声明相关的属性  方法 构造器

        }
        class Animal extends  Creature{


        }
        class Dog extends Animal{

       }
       class DogTest{
       public static void main(String[] args) {
       Dog d=new Dog();
       d.xxx();//
       d.xxx=...;

       }

       }


       1-1：从结果的角度来看，体现为类的继承性
        当我们创建了子类对象后，子类对象就获取了其父类声明的所有的属性和方法，在权限允许的情况下，可以直接调用。
        1-2：从过程的角度来看：
        我们通过子类的构造器创建对象时，子类的构造器一定会直接或间接的调用父类的构造器，而其父类的构造器同样会
        直接或简洁的调用到其父类的父类的构造器，直到调用Object类中的构造器为止。
        正因为我们通过调用子类所有父类的构造器，所以我们就会将父类声明的属性、方法加载到内存中，供子类使用。
